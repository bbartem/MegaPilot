#include "iarduino_I2C_Matrix_8x8.h"																					//
																														//
//		Инициализация дисплея:																							//	Возвращаемое значение: результат инициализации.
bool	iarduino_I2C_Matrix_8x8::begin			(void){																	//	Параметр: отсутствует
			uint8_t tmpImage[8];																						//	Объявляем массив для временного хранения изображения экрана.
		//	Инициируем работу с шиной I2C:																				//
			objI2C->begin(100);																							//	Инициируем передачу данных по шине I2C на скорости 100 кГц.
		//	Если адрес не указан, то ищим модуль на шине I2C:															//
			if(valAddrTemp==0){																							//
				for(int i=1; i<127; i++){																				//	Проходим по всем адресам на шине I2C
					if( objI2C->checkAddress(i)											){	valAddr=i; delay(2);		//	Если на шине I2C есть устройство с адресом i, то используем этот адрес для проверки найденного модуля...
					if(_readBytes(REG_MODEL,4)											){								//	Читаем 4 байта начиная с регистра «REG_MODEL» в массив «data».
					if( data[0]     == DEF_MODEL_8X8									){								//	Если у модуля с адресом i в регистре «MODEL»   (data[0]) хранится значение DEF_MODEL_8X8, то ...
					if((data[2]>>1) == i                 || data[2] == 0xFF				){								//	Если у модуля с адресом i в регистре «ADDRESS» (data[2]) хранится значение i (адрес+младший бит) или 0xFF (адрес не задавался), то ...
					if( data[3]     == DEF_CHIP_ID_FLASH || data[3] == DEF_CHIP_ID_METRO){								//	Если у модуля с адресом i в регистре «CHIP_ID» (data[3]) хранится значение DEF_CHIP_ID_FLASH (идентификатор модулей Flash), или DEF_CHIP_ID_METRO (идентификатор модулей Metro), то ...
						valAddrTemp=i; i=128;																			//	Считаем что модуль обнаружен, сохраняем значение i как найденный адрес и выходим из цикла.
					}}}}}																								//
				}																										//
			}																											//
		//	Если модуль не найден, то возвращаем ошибку инициализации:													//
			if( valAddrTemp == 0														){	valAddr=0; return false;}	//
		//	Проверяем наличие модуля на шине I2C:																		//
			if( objI2C->checkAddress(valAddrTemp) == false								){	valAddr=0; return false;}	//	Если на шине I2C нет устройств с адресом valAddrTemp, то возвращаем ошибку инициализации
			valAddr=valAddrTemp;																						//	Сохраняем адрес модуля на шине I2C.
		//	Проверяем значения регистров модуля:																		//
			if(_readBytes(REG_MODEL,4)==false											){	valAddr=0; return false;}	//	Если не удалось прочитать 4 байта в массив «data» из модуля начиная с регистра «REG_MODEL», то возвращаем ошибку инициализации.
			if( data[0]     != DEF_MODEL_8X8											){	valAddr=0; return false;}	//	Если значение  регистра «MODEL»   (data[0]) не совпадает со значением DEF_MODEL_8X8, то возвращаем ошибку инициализации.
			if((data[2]>>1) != valAddrTemp       && data[2] !=0xFF						){	valAddr=0; return false;}	//	Если значение  регистра «ADDRESS» (data[2]) не совпадает с адресом модуля и не совпадает со значением 0xFF, то возвращаем ошибку инициализации.
			if( data[3]     != DEF_CHIP_ID_FLASH && data[3] != DEF_CHIP_ID_METRO		){	valAddr=0; return false;}	//	Если значение  регистра «CHIP_ID» (data[3]) не совпадает со значением DEF_CHIP_ID_FLASH и DEF_CHIP_ID_METRO, то возвращаем ошибку инициализации.
			valVers=data[1];																							//	Сохраняем байт регистра «VERSION» (data[1]) в переменую «valVers».
		//	Определяем значения переменных:																				//	
	        objI2C->readByte(valAddr,REG_FLAGS_0);																		//	Читаем флаги регистра «REG_FLAGS_0» в никуда.
			data[0]=0;   _writeBytes(REG_8X8_SYMBOL_INPUT,1);															//	Загружаем 0 в регистр «SYMBOL_INPUT», тогда символ с кодом 0 отобразится на дисплее, но это не символ, а значения ширины, интервала и отступа символов.
			getImage(tmpImage);																							//	Сохраняем текущее изображение дисплея в массив tmpImage.
			charWidth=tmpImage[0];																						//	Извлекаем значение ширины символов.
			charInterval=tmpImage[1];																					//	Извлекаем значение межсимвольного интервала.
			charIndent=tmpImage[2];																						//	Извлекаем значение отступа символа от левого края экрана.
			delay(5);																									//
			clrScr();																									//	Чистим экран.
			return true;																								//	Возвращаем флаг успешной инициализаии.
}																														//
																														//
//		Смена адреса модуля:																							//	Возвращаемое значение:	резульат смены адреса.
bool	iarduino_I2C_Matrix_8x8::changeAddress	(uint8_t newAddr){														//	Параметр:				newAddr - новый адрес модуля.
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
		//	Проверяем новый адрес:																						//
			if(newAddr>0x7F){newAddr>>=1;}																				//	Корректируем адрес, если он указан с учётом бита RW.
			if(newAddr==0x00 || newAddr==0x7F){return false;}															//	Запрещаем устанавливать адрес 0x00 и 0x7F.
		//	Записываем новый адрес:																						//
			if(_readBytes(REG_BITS_0,1)==false){return false;}															//	Читаем 1 байт регистра «BITS_0» в массив data.
			data[0] |= 0b00000010;																						//	Устанавливаем бит «SET_PIN_ADDRES»
			if(_writeBytes(REG_BITS_0,1)==false){return false;}															//	Записываем 1 байт в регистр «BITS_0» из массива data.
			data[0] = (newAddr<<1)|0x01;																				//	Готовим новый адрес к записи в модуль.
			if(_writeBytes(REG_ADDRESS,1)==false){return false;}														//	Записываем 1 байт в регистр «ADDRESS» из массива data.
			delay(200);																									//	Даём более чем достаточное время для применения модулем нового адреса.
		//	Проверяем наличие модуля с новым адресом на шине I2C:														//
			if(objI2C->checkAddress(newAddr)==false){return false;}														//	Если на шине I2C нет модуля с адресом newAddr, то возвращаем ошибку.
			valAddr     = newAddr;																						//	Сохраняем новый адрес как текущий.
			valAddrTemp = newAddr;																						//	Сохраняем новый адрес как указанный.
			return true;																								//	Возвращаем флаг успеха.
		}else{																											//	Иначе, если дисплей не инициализирован, то ...
			return false;																								//	Возвращаем ошибку
		}																												//
}																														//
																														//
//		Перезагрузка модуля:																							//	Возвращаемое значение:	результат перезагрузки.
bool	iarduino_I2C_Matrix_8x8::reset			(void){																	//	Параметр:				отсутствует.
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
		//	Устанавливаем бит перезагрузки:																				//
			if(_readBytes(REG_BITS_0,1)==false){return false;}															//	Читаем 1 байт регистра «BITS_0» в массив data.
			data[0] |= 0b10000000;																						//	Устанавливаем бит «SET_RESET»
			if(_writeBytes(REG_BITS_0,1)==false){return false;}															//	Записываем 1 байт в регистр «BITS_0» из массива data.
		//	Ждём установки флага завершения перезагрузки:																//
			do{ if(_readBytes(REG_FLAGS_0,1)==false){return false;} }													//	Читаем 1 байт регистра «REG_FLAGS_0» в массив data.
			while( (data[0]&0b10000000) == 0);																			//	Повторяем чтение пока не установится флаг «FLG_RESET».
			return true;																								//
		}else{																											//	Иначе, если дисплей не инициализирован, то ...
			return false;																								//	Возвращаем ошибку
		}																												//
}																														//
																														//
//		Автоопределение кодировки:																						//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::codingDetect	(const char* str){														//	Параметр:				строка состоящая из символа 'п' и символа конца строки.
					if(strlen (str   )==   2){codingName=X8_TXT_UTF8;   }												//	Если символ 'п' занимает 2 байта, значит текст скетча в кодировке UTF8.
			else	if(uint8_t(str[0])==0xAF){codingName=X8_TXT_CP866;  }												//	Если символ 'п' имеет код 175, значит текст скетча в кодировке CP866.
			else	if(uint8_t(str[0])==0xEF){codingName=X8_TXT_WIN1251;}												//	Если символ 'п' имеет код 239, значит текст скетча в кодировке WIN1251.
}																														//
																														//
//		Очистить дисплей:																								//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::clrScr			(uint8_t func){															//	Параметр:				функция анимации исчезания или 0.
		if(func<100){func=0;}																							//
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
		//	Очистка дисплея с анимацией:																				//
			if(func){																									//
			//	Определяем номер функции анимации:																		//
				data[0] = func-100;																						//	func=100,101,102,103 => data[0]=0x04 - Исчезновение рябью       в пустой фон
				data[0]/=4;																								//	func=104,105,106,107 => data[0]=0x08 - Исчезновение сверху-вниз в пустой фон
				data[0]*=4;																								//	func=108,109,110,111 => data[0]=0x0C - Исчезновение снизу-вверх в пустой фон
				data[0]+=4;																								//	func=...
			//	Записываем номер функции анимации:																		//
				_writeBytes(REG_8X8_FUNCTIONS,1);																		//	Записываем 1 байт в регистр «FUNCTIONS» из массива data.
			//	Ждём сброса регистра анимации:																			//
				do{ _readBytes(REG_8X8_FUNCTIONS,1); delay(500); }while( data[0] > 0 );									//	Читаем 1 байт регистра «FUNCTIONS» в массив data, пока значение этого регистра не будет сброшено.
		//	Очистка дисплея без анимации:																				//
			}else{																										//
			//	Останавливаем бегущую строку:																			//
				data[0]=0; _writeBytes(REG_8X8_TIME_STEP,1);															//	Сбрасываем регистр «TIME_STEP» для остановки бегущей строки, если она сейчас выводится.
			//	Устанавливаем бит очистки дисплея:																		//
				_readBytes(REG_8X8_DATA,1);																				//	Читаем 1 байт регистра «REG_8X8_DATA» в массив data.
				data[0] |= 0b00010000;																					//	Устанавливаем бит «CLEAR_SCR»
				_writeBytes(REG_8X8_DATA,1);																			//	Записываем 1 байт в регистр «REG_8X8_DATA» из массива data.
			//	Ждём сброса бита очистки дисплея:																		//
				do{ _readBytes(REG_8X8_DATA,1); }while( (data[0]&0b00010000) > 0 );										//	Читаем 1 байт регистра «REG_8X8_DATA» в массив data, пока в нём не сбросится бит «CLEAR_SCR».
			}																											//
		}																												//
}																														//
																														//
//		Залить дисплей:																									//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::fillScr		(uint8_t func){															//	Параметр:				функция анимации исчезания или 0.
		if(func<100){func=0;}																							//
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
		//	Заливка дисплея с анимацией:																				//
			if(func){																									//
			//	Определяем номер функции анимации:																		//
				data[0] = func-100;																						//	func=100,101,102,103 => data[0]=0x06 - Исчезновение рябью       в закрашенный фон
				data[0]/=4;																								//	func=104,105,106,107 => data[0]=0x0A - Исчезновение сверху-вниз в закрашенный фон
				data[0]*=4;																								//	func=108,109,110,111 => data[0]=0x0E - Исчезновение снизу-вверх в закрашенный фон
				data[0]+=6;																								//	func=...
			//	Записываем номер функции анимации:																		//
				_writeBytes(REG_8X8_FUNCTIONS,1);																		//	Записываем 1 байт в регистр «FUNCTIONS» из массива data.
			//	Ждём сброса регистра анимации:																			//
				do{ _readBytes(REG_8X8_FUNCTIONS,1); delay(500); }while( data[0] > 0 );									//	Читаем 1 байт регистра «FUNCTIONS» в массив data, пока значение этого регистра не будет сброшено.
		//	Заливка дисплея без анимации:																				//
			}else{																										//
			//	Останавливаем бегущую строку:																			//
				data[0]=0; _writeBytes(REG_8X8_TIME_STEP,1);															//	Сбрасываем регистр «TIME_STEP» для остановки бегущей строки, если она сейчас выводится.
			//	Устанавливаем бит очистки дисплея:																		//
				_readBytes(REG_8X8_DATA,1);																				//	Читаем 1 байт регистра «REG_8X8_DATA» в массив data.
				data[0] |= 0b00100000;																					//	Устанавливаем бит «FILL_SCR»
				_writeBytes(REG_8X8_DATA,1);																			//	Записываем 1 байт в регистр «REG_8X8_DATA» из массива data.
			//	Ждём сброса бита очистки дисплея:																		//
				do{ _readBytes(REG_8X8_DATA,1); }while( (data[0]&0b00100000) > 0 );										//	Читаем 1 байт регистра «REG_8X8_DATA» в массив data, пока в нём не сбросится бит «FILL_SCR».
			}																											//
		}																												//
}																														//
																														//
//		Инверсия цветов:																								//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::invScr			(void){																	//	Параметр:				отсутствует.
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			delay(5);																									//	Ждём 5мс. Это время требуется для выздать если функция invScr() была запущена сразу после вывода числа или символа.
			_readBytes(REG_8X8_DATA+1,8);																				//	Читаем 8 байт начиная с регистра «REG_8X8_DATA_1» в массив data.
			for(int i=0; i<8; i++){ data[i] = ~data[i]; }																//	Инвертируем все биты в 8 элементах массива data.
			_writeBytes(REG_8X8_DATA+1,8);																				//	Записываем 8 байт в регистры начиная с «REG_8X8_DATA_1» из массива data.
		}																												//
}																														//
																														//
//		Вывод изображения:																								//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::drawImage		(uint8_t* arr, uint8_t i, uint8_t j){									//	Параметры:				массив с изображением, [функция анимации появления] , и или [тип памяти массива].
		uint8_t func=0;   if(i>99){func=i;} if(j>99){func=j;} if(func%2){func--;}										//	Определяем наличие функции анимации в переданных параметрах.
		uint8_t memArr=X8_IMG_RAM; if(i==X8_IMG_ROM){memArr=X8_IMG_ROM;} if(j==X8_IMG_ROM){memArr=X8_IMG_ROM;}			//	Определяем наличие указаний, что изобрадение хранится в ПЗУ.
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
		//	Останавливаем бегущую строку:																				//
			data[0]=0; _writeBytes(REG_8X8_TIME_STEP,1);																//	Сбрасываем регистр «TIME_STEP» для остановки бегущей строки, если она сейчас выводится.
		//	Если указано использовать анимацию появления, то:															//
			if(func){																									//
				if(func%4<2){																							//	X8_EMPTY_...: 100, 104, 108 ... 
				//	Если указана функция появления из пустого фона:														//	
					data[0]=1; _writeBytes(REG_8X8_FUNCTIONS,1);														//	Загружаем номер анимации предварительной очистки дисплея в регистр «FUNCTIONS».
				}else{																									//	X8_FILLED_...: 102, 106, 110 ...
				//	Если указана функция появления из закрашенного фона:												//	
					data[0]=2; _writeBytes(REG_8X8_FUNCTIONS,1);														//	Загружаем номер анимации предварительной заливки дисплея в регистр «FUNCTIONS».
				}																										//
				delay(50);																								//	Ждём применения функции предварительной очистки/закраски дисплея
			}																											//
		//	Загружаем изображение:																						//
			for(int k=0; k<8; k++){ if(memArr==X8_IMG_RAM){ data[k]=arr[k]; }else{ data[k]=pgm_read_byte(&arr[k]); }}	//	Получаем данные для массива data по адресу arr из ОЗУ или ПЗУ.
			_writeBytes(REG_8X8_DATA+1,8);																				//	Записываем 8 байт массива data в модуль начиная с регистра «REG_8X8_DATA_1».
		//	Если указано использовать анимацию появления, то:															//
			if(func){																									//
			//	Определяем и загружаем номер функции в регистр анимации:												//
				data[0]=func-100+3;																						//	100=>3, 102=>5, 104=>7, 106=>9, 108=>B, 110=>D ...
				_writeBytes(REG_8X8_FUNCTIONS,1);																		//
			//	Ждём сброса регистра анимации:																			//
				do{ _readBytes(REG_8X8_FUNCTIONS,1); delay(500); }while( data[0] > 0 );									//	Читаем 1 байт регистра «FUNCTIONS» в массив data, пока значение этого регистра не будет сброшено.
			}																											//
		}																												//
}																														//
																														//
//		Вывод цифры:																									//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::_printNum		(uint8_t num, uint8_t func){											//	Параметры:				цифра, [функция анимации появления].
		num%=10;																										//	Делаем из числа цифру.
		if(func%2){func--;}																								//	Делаем номер функции чётным: 101=>100, 103=>102, 105=>104, ...
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
		//	Останавливаем бегущую строку:																				//
			data[0]=0; _writeBytes(REG_8X8_TIME_STEP,1);																//	Сбрасываем регистр «TIME_STEP» для остановки бегущей строки, если она сейчас выводится.
		//	Если указано использовать анимацию появления, то:															//
			if(func){																									//
				if(func%4<2){																							//	X8_EMPTY_...: 100, 104, 108 ... 
				//	Если указана функция появления из пустого фона:														//	
					data[0]=1; _writeBytes(REG_8X8_FUNCTIONS,1);														//	Загружаем номер анимации предварительной очистки дисплея в регистр «FUNCTIONS».
				}else{																									//	X8_FILLED_...: 102, 106, 110 ...
				//	Если указана функция появления из закрашенного фона:												//	
					data[0]=2; _writeBytes(REG_8X8_FUNCTIONS,1);														//	Загружаем номер анимации предварительной заливки дисплея в регистр «FUNCTIONS».
				}																										//
				delay(50);																								//	Ждём применения функции предварительной очистки/закраски дисплея
			}																											//
		//	Загружаем цифру:																							//
			data[0]=num+0x30; _writeBytes(REG_8X8_SYMBOL_INPUT,1);														//	Загружаем код символа цифры в регистр «SYMBOL_INPUT», тогда символ цифры отобразится на дисплее.
		//	Если указано использовать анимацию появления, то:															//
			if(func){																									//
			//	Определяем и загружаем номер функции в регистр анимации:												//
				data[0]=func-100+3;																						//	100=>3, 102=>5, 104=>7, 106=>9, 108=>B, 110=>D ...
				_writeBytes(REG_8X8_FUNCTIONS,1);																		//
			//	Ждём сброса регистра анимации:																			//
				do{ _readBytes(REG_8X8_FUNCTIONS,1); delay(500); }while( data[0] > 0 );									//	Читаем 1 байт регистра «FUNCTIONS» в массив data, пока значение этого регистра не будет сброшено.
			}																											//
		}																												//
}																														//
																														//
//		Вывод символа или загрузка строки:																				//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::_printStr		(String str, uint8_t func){												//	Параметры:				символ или строка, [функция анимации появления].
		if(str.length()==0){return;}																					//
		if(func%2){func--;}																								//	Делаем номер функции чётным: 101=>100, 103=>102, 105=>104, ...
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
		//	Останавливаем бегущую строку:																				//
			data[0]=0; _writeBytes(REG_8X8_TIME_STEP,1);																//	Сбрасываем регистр «TIME_STEP» для остановки бегущей строки, если она сейчас выводится.
		//	Если указано использовать анимацию появления, то:															//
			if(func){																									//
				if(func%4<2){																							//	X8_EMPTY_...: 100, 104, 108 ... 
				//	Если указана функция появления из пустого фона:														//	
					data[0]=1; _writeBytes(REG_8X8_FUNCTIONS,1);														//	Загружаем номер анимации предварительной очистки дисплея в регистр «FUNCTIONS».
				}else{																									//	X8_FILLED_...: 102, 106, 110 ...
				//	Если указана функция появления из закрашенного фона:												//	
					data[0]=2; _writeBytes(REG_8X8_FUNCTIONS,1);														//	Загружаем номер анимации предварительной заливки дисплея в регистр «FUNCTIONS».
				}																										//
				delay(50);																								//	Ждём применения функции предварительной очистки/закраски дисплея
			}																											//
		//	Если str содержит 1 символ, то выводим его на дисплей:														//
			if((str.length()==1)||(str.length()==2&&codingName==X8_TXT_UTF8&&(uint8_t(str[0])==208||uint8_t(str[0])==209))){// Если в str 1 символ или (в str 2 символа в кодировке UTF8 и код первого символа равен 208 или 209), то ...
				data[0]=_codingCP866(str).charAt(0); _writeBytes(REG_8X8_SYMBOL_INPUT,1);									//	Загружаем код символа в регистр «SYMBOL_INPUT», тогда символ отобразится на дисплее.
		//	Если str содержит строку, то загружаем её в модуль:															//
			}else{																										//
			//	Устанавливаем бит очистки текста бегущей строки:														//
				_readBytes(REG_8X8_DATA,1);																				//	Читаем 1 байт регистра «REG_8X8_DATA» в массив data.
				data[0] |= 0b00001000;																					//	Устанавливаем бит «CLEAR_STR»
				_writeBytes(REG_8X8_DATA,1);																			//	Записываем 1 байт в регистр «REG_8X8_DATA» из массива data.
			//	Ждём сброса бита очистки текста:																		//
				do{ _readBytes(REG_8X8_DATA,1); }while( (data[0]&0b00001000) > 0 );										//	Читаем 1 байт регистра «REG_8X8_DATA» в массив data, пока в нём не сбросится бит «CLEAR_STR».
			//	Определяем количество символов которое требуется записать в память дисплея								//
				stringLen=_codingCP866(str).length();																	//	Определяем количество символов строки str в кодировке CP866.
			//	Загружаем новую строку посимвольно:																		//
				for(int i=0; i<stringLen; i++){																			//	Проходим по всем символам строки str в кодировке CP866 ...
					data[0]=_codingCP866(str).charAt(i); _writeBytes(REG_8X8_TEXT_INPUT,1);								//	Извлекаем код очередного символа из строки str и загружаем его в регистр «TEXT_INPUT».
				    do{ _readBytes(REG_8X8_TEXT_INPUT,1); }while( data[0] > 0 );										//	Читаем 1 байт регистра «TEXT_INPUT» в массив data, пока значение этого регистра не будет сброшено.
				}	data[0]=0; _writeBytes(REG_8X8_TEXT_INPUT,1);														//	Загружаем код символа конца строки в регистр «TEXT_INPUT».
			}																											//
		//	Если указано использовать анимацию появления, то:															//
			if(func){																									//
			//	Определяем и загружаем номер функции в регистр анимации:												//
				data[0]=func-100+3;																						//	100=>3, 102=>5, 104=>7, 106=>9, 108=>B, 110=>D ...
				_writeBytes(REG_8X8_FUNCTIONS,1);																		//
			//	Ждём сброса регистра анимации:																			//
				do{ _readBytes(REG_8X8_FUNCTIONS,1); delay(500); }while( data[0] > 0 );									//	Читаем 1 байт регистра «FUNCTIONS» в массив data, пока значение этого регистра не будет сброшено.
			}																											//
		}																												//
}																														//
																														//
//		Установка скорости бегущей строки:																				//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::autoScroll		(uint8_t speed, uint16_t pause){										//	Параметр:				скорость от 0 до 255, [пауза от 0 до 25500 мс]).
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			data[0] = uint8_t(256-speed);																				//	Определяем значение для регистра «TIME_STEP»  Время затрачиваемое на один шаг автопрокрутки бегущей строки в сотых долях секунд от 0 (0,00 сек) до 255 (2,55 сек).
			data[1] = uint8_t(pause/100);																				//	Определяем значение для регистра «TIME_PAUSE» Время паузы до повторной автопрокрутки всей бегущей строки в десятых долях секунд от 0 (0,0 сек)  до 255 (25.5 сек).
			_writeBytes(REG_8X8_TIME_STEP,2);																			//	Загружаем 2 байта массива data в модуль начиная с регистра «TIME_STEP».
		}																												//
}																														//
																														//
//		Установка позиции бегущей строки:																				//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::scrollPos		(uint16_t pos){															//	Параметр:				позиция (либо в пикселях, либо в символах, зависит от scrollMod).
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
		//	Записываем значение в регистр сдвига бегущей строки:														//
			data[0] = lowByte (pos);																					//	Сохраняем младший байт из pos в массив data.
			data[1] = highByte(pos);																					//	Сохраняем старший байт из pos в массив data.
			_writeBytes(REG_8X8_STEP_LEN,2);																			//	Записываем 2 байта в двухбайтный регистр «STEP_LEN» из массива data.
		//	Ждём сброса регистра сдвига бегущей строки:																	//
			do{ _readBytes(REG_8X8_STEP_LEN,2); }while( (data[0]>0)||(data[1]>0) );										//	Читаем 2 байта двухбайтного регистра «REG_8X8_DATA» в массив data, пока оба байта не сбросятся в 0.
		}																												//
}																														//
																														//
//		Выбор направления движения бегущей строки:																		//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::scrollDir		(bool f){																//	Параметр:				направление (1-право/0-лево).
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			_readBytes(REG_8X8_DATA,1);																					//	Читаем 1 байт регистра «REG_8X8_DATA» в массив data.
			if(f){data[0] |= 0b00000010;}																				//	Устанавливаем бит «STEP_ROUTE».
			else {data[0] &= 0b11111101;}																				//	Сбрасываем    бит «STEP_ROUTE».
			_writeBytes(REG_8X8_DATA,1);																				//	Записываем 1 байт в регистр «REG_8X8_DATA» из массива data.
		}																												//
}																														//
																														//
//		Выбор режима прокрутки бегущей строки:																			//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::scrollMod		(bool f){																//	Параметр:				режим (1-посимвольный/0-попиксельный).
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			_readBytes(REG_8X8_DATA,1);																					//	Читаем 1 байт регистра «REG_8X8_DATA» в массив data.
			if(f){data[0] |= 0b00000100;}																				//	Устанавливаем бит «STEP_MOD».
			else {data[0] &= 0b11111011;}																				//	Сбрасываем    бит «STEP_MOD».
			_writeBytes(REG_8X8_DATA,1);																				//	Записываем 1 байт в регистр «REG_8X8_DATA» из массива data.
		}																												//
}																														//
																														//
//		Пошаговый сдвиг бегущей строки:																					//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::scrollStep		(void){																	//	Параметр:				отсутствует.
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			data[0] = 0b10000000;																						//	Устанавливаем бит «STEP_ONE».
			_writeBytes(REG_8X8_STEP_LEN+1,1);																			//	Записываем 1 байт в старший байт двухбайтного регистра «STEP_LEN» из массива data.
		}																												//
}																														//
																														//
//		Установка времени простоя на первом символе бегущей строки:														//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::setTimeIdleFirst(uint16_t time){														//	Параметр:				время простоя в мс.
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			data[0] = uint8_t(time/10);																					//	Определяем значение для регистра «TIME_START» Время простоя на первом символе бегущей строки в сотых долях секунд от 0 (0,00 сек) до 255 (2.55 сек).
			_writeBytes(REG_8X8_TIME_START,1);																			//	Загружаем 1 байт массива data в регистр «TIME_START».
		}																												//
}																														//
																														//
//		Установка времени простоя на последнем символе бегущей строки:													//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::setTimeIdleLast(uint16_t time){														//	Параметр:				время простоя в мс.
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			data[0] = uint8_t(time/10);																					//	Определяем значение для регистра «TIME_STOP» Время простоя на последнем символе бегущей строки в сотых долях секунд от 0 (0,00 сек) до 255 (2.55 сек).
			_writeBytes(REG_8X8_TIME_STOP,1);																			//	Загружаем 1 байт массива data в регистр «TIME_STOP».
		}																												//
}																														//
																														//
//		поворот дисплея:																								//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::angle			(uint16_t deg){															//	Параметр:				угол 0°, 90°, 180°, 270°.
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			_readBytes(REG_8X8_DATA,1);																					//	Читаем 1 байт регистра «REG_8X8_DATA» в массив data.
			data[0] &= 0b00111111;																						//	Сбрасываем биты «TURN».
			data[0] |= (uint8_t(deg/90)<<6);																			//	Устанавливаем биты «TURN» в соответствии со значением deg.
			_writeBytes(REG_8X8_DATA,1);																				//	Записываем 1 байт в регистр «REG_8X8_DATA» из массива data.
		}																												//
}																														//
																														//
//		Установка скорости обновления дисплея:																			//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::fps			(uint8_t i){															//	Параметр:				количество кадров в секунду от 10 до 255.
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			data[0] = (i<10)? 10:i;																						//	Сохраняем количество кадров в массив data.
			_writeBytes(REG_FREQUENCY,1);																				//	Загружаем 1 байт массива data в регистр «FREQUENCY».
		}																												//
}																														//
																														//
//		Установка яркости дисплея:																						//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::bright			(uint8_t i){															//	Параметр:				яркость от 0 до 255.
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			data[0] = i;																								//	Сохраняем яркость в массив data.
			_writeBytes(REG_BRIGHTNESS,1);																				//	Загружаем 1 байт массива data в регистр «BRIGHTNESS».
		}																												//
}																														//
																														//
//		Замена изображения символа:																						//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::changeChar		(uint8_t i){															//	Параметр:				код символа изображение которого требуется изменить.
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			if(i==0){return;}																							//
		//	Записываем код символа в регистр перезаписи изображения символа:											//
			data[0]=i; _writeBytes(REG_8X8_SAVE_AS,1);																	//	Записываем 1 байт в регистр «SAVE_AS» из массива data.
		//	Ждём сброса регистра перезаписи изображения символа:														//
			do{ _readBytes(REG_8X8_SAVE_AS,1); }while( data[0]>0 );														//	Читаем 1 байт регистра «SAVE_AS» в массив data, пока он не сбросятся в 0.
		}																												//
}																														//
																														//
//		Установка ширины изображений всех символов:																		//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::setCharWidth	(uint8_t i){															//	Параметр:				ширина символов в пикселях от 3 до 7.
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			if( (i<3)||(i>7) ){return;} charWidth=i; _setChar0();														//	Проверяем введённые данные и сохраняем их.
		}																												//
}																														//
																														//
//		Установка межсимвольного интервала:																				//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::setCharInterval(uint8_t i){															//	Параметр:				межсимвольный интервал в пикселях.
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			charInterval=i; _setChar0();																				//	Сохраняем межсимвольный интервал.
		}																												//
}																														//
																														//
//		Установка отступа от левого края до символа:																	//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::setCharIndent	(uint8_t i){															//	Параметр:				отступ от левого края в пикселях.
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			if( i>=8 ){return;} charIndent = i; _setChar0();															//	Проверяем введённые данные и сохраняем их.
		}																												//
}																														//
																														//
//		Установка ширины, интервала и отступа символов:																	//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::_setChar0		(void){																	//	Объявляем  функцию установки ширины, интервала и отступа символов	(Параметр:   отсутствует).
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			uint8_t tmpImage[8];																						//	Объявляем массив для временного хранения изображения экрана.
			uint8_t tmpImageChar0[8];																					//	Объявляем массив для временного хранения изображения символа с кодом 0.
			uint8_t tmpTimeStep;																						//	Объявляем переменную для временного хранения времени затрачиваемого на один шаг автопрокрутки бегущей строки.
		//	Готовим изображение символа с кодом 0:																		//
			memset(tmpImageChar0,0,8);																					//	Чистим массив tmpImageChar0
			tmpImageChar0[0]=charWidth;																					//	Добавляем в массив tmpImageChar0 значение ширины символов.
			tmpImageChar0[1]=charInterval;																				//	Добавляем в массив tmpImageChar0 значение межсимвольного интервала.
			tmpImageChar0[2]=charIndent;																				//	Добавляем в массив tmpImageChar0 значение отступа от левого края экрана до символа.
		//	Останавливаем бегущую строку:																				//
			_readBytes(REG_8X8_TIME_STEP,1); tmpTimeStep=data[0];														//	Читаем 1 байт из регистра «TIME_STEP» через массив data в переменную tmpTimeStep.
			if(tmpTimeStep>0){ data[0]=0; _writeBytes(REG_8X8_TIME_STEP,1); }											//	Если включена автопрокрутка бегущей строки (tmpTimeStep>0) то останавливаем бегущую строку сбросив регистр «TIME_STEP» в 0.
		//	Сохраняем текущее изображение матрицы в массив tmpImage:													//
			getImage(tmpImage);																							//	Сохраняем текущее изображение матрицы в массив tmpImage.
		//	Сохраняем изображение символа с кодом 0:																	//
			drawImage(tmpImageChar0);																					//	Выводим изображение из массива tmpImageChar0
			data[0]=0; _writeBytes(REG_8X8_SAVE_AS,1);																	//	Записываем 1 байт в регистр «SAVE_AS» из массива data.
			delay(50);																									//	Ждём пока изображение экрана не сохранится в таблицу символов.
		//	Восстанавливаем изображение экрана на то, что было до вызова функции _setChar0():							//
			if(tmpTimeStep>0){ data[0]=tmpTimeStep; _writeBytes(REG_8X8_TIME_STEP,1); }									//	Если прокручивалась бегущая строка, то возобновляем её прокрутку.
			else{drawImage(tmpImage);}																					//	Иначе восстанавливаем изображение.
		}																												//
}																														//
																														//
//		Получение массива с данными текущего изображения на экране:														//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_Matrix_8x8::getImage		(uint8_t* i){															//	Параметр:				указатель на массив в который требуется сохранить изображение.
		if(valAddr){																									//	Если дисплей был инициализирован, то ...
			delay(5);																									//	Ждём 5мс. Это время требуется для выздать если функция invScr() была запущена сразу после вывода числа или символа.
			_readBytes(REG_8X8_DATA+1,8);																				//	Читаем 8 байт начиная с регистра «REG_8X8_DATA_1» в массив data.
			for(int j=0; j<8; j++){ i[j] = data[j]; }																	//	Копируем данный массива data в массив i.
		}																												//
}																														//
																														//
//		Чтение данных из регистров в массив data:																		//	Возвращаемое значение:	результат чтения (true/false).
bool	iarduino_I2C_Matrix_8x8::_readBytes		(uint8_t reg, uint8_t sum){												//	Параметры:				reg - номер первого регистра, sum - количество читаемых байт.
			bool	result=false;																						//	Определяем флаг       для хранения результата чтения.
			uint8_t	sumtry=10;																							//	Определяем переменную для подсчёта количества оставшихся попыток чтения.
			do{	result = objI2C->readBytes(valAddr, reg, data, sum);													//	Считываем из модуля valAddr, начиная с регистра reg, в массив data, sum байт.
				sumtry--;	if(!result){delay(1);}																		//	Уменьшаем количество попыток чтения и устанавливаем задержку при неудаче.
			}	while		(!result && sumtry>0);																		//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
			delayMicroseconds(500);																						//	Между пакетами необходимо выдерживать паузу.
			return result;																								//	Возвращаем результат чтения (true/false).
}																														//
																														//
//		Запись данных в регистры из массива data:																		//	Возвращаемое значение:	результат записи (true/false).
bool	iarduino_I2C_Matrix_8x8::_writeBytes	(uint8_t reg, uint8_t sum, uint8_t num){								//	Параметры:				reg - номер первого регистра, sum - количество записываемых байт, num - номер первого элемента массива data.
			bool	result=false;																						//	Определяем флаг       для хранения результата записи.
			uint8_t	sumtry=10;																							//	Определяем переменную для подсчёта количества оставшихся попыток записи.
			do{	result = objI2C->writeBytes(valAddr, reg, &data[num], sum);												//	Записываем в модуль valAddr начиная с регистра reg, sum байи из массива data начиная с элемента num.
				sumtry--;	if(!result){delay(1);}																		//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
			}	while		(!result && sumtry>0);																		//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
			delayMicroseconds(500);																						//	Между пакетами необходимо выдерживать паузу.
			return result;																								//	Возвращаем результат записи (true/false).
}																														//
																														//
//		Преобразование строки из кодировки codingName в кодировку CP866													//	Возвращаемое значение:	строка в кодировке CP866.
String	iarduino_I2C_Matrix_8x8::_codingCP866	(String StrIn){															//	Параметр:				строка в кодировке codingName.
			String StrOut;																								//	Определяем строку для вывода результата.
			uint8_t	i = 0;																								//	Определяем переменную хранящую номер символа в строке StrIn.
			switch(codingName){																							//	Тип кодировки строки StrIn.
			//	Преобразуем текст из кодировки UTF-8:																												//
				case X8_TXT_UTF8:																																	//
					while ( uint8_t(StrIn[i])> 0    && i                  < 0xFF                              ){													//	Если код текущего символа строки StrIn больше 0 и № текушего символа строки StrIn меньше 255, то ...
						if( uint8_t(StrIn[i])==0xD0 && uint8_t(StrIn[i+1])>=0x90 && uint8_t(StrIn[i+1])<=0xBF ){StrOut+=char(uint8_t(StrIn[i+1])-0x10); i++;}else	//	Если код текущего символа равен 208, а за ним следует символ с кодом 144...191, значит это буква «А»...«п» требующая преобразования к коду 128...175
						if( uint8_t(StrIn[i])==0xD0 && uint8_t(StrIn[i+1])==0x81                              ){StrOut+=                         0xF0 ; i++;}else	//	Если код текущего символа равен 208, а за ним следует символ с кодом 129      , значит это буква «Ё»       требующая преобразования к коду 240
						if( uint8_t(StrIn[i])==0xD1 && uint8_t(StrIn[i+1])>=0x80 && uint8_t(StrIn[i+1])<=0x8F ){StrOut+=char(uint8_t(StrIn[i+1])+0x60); i++;}else	//	Если код текущего символа равен 209, а за ним следует символ с кодом 128...143, значит это буква «р»...«я» требующая преобразования к коду 224...239
						if( uint8_t(StrIn[i])==0xD1 && uint8_t(StrIn[i+1])==0x91                              ){StrOut+=                         0xF1 ; i++;}else	//	Если код текущего символа равен 209, а за ним следует символ с кодом 145      , значит это буква «ё»       требующая преобразования к коду 241
						                                                                                       {StrOut+=char(        StrIn[i]        );     } i++;	//	Иначе не меняем символ.
					}																																				//
				break;																																				//
			//	Преобразуем текст из кодировки WINDOWS-1251:																										//
				case X8_TXT_WIN1251:																																//
					while ( uint8_t(StrIn[i])> 0    && i                < 0xFF ){																					//	Если код текущего символа строки StrIn больше 0 и № текушего символа строки StrIn меньше 255, то ...
						if( uint8_t(StrIn[i])>=0xC0 && uint8_t(StrIn[i])<=0xEF ){StrOut+=char(uint8_t(StrIn[i])-0x40);}else											//	Если код текущего символа равен 192...239, значит это буква «А»...«п» требующая преобразования к коду 128...175
						if( uint8_t(StrIn[i])>=0xF0 && uint8_t(StrIn[i])<=0xFF ){StrOut+=char(uint8_t(StrIn[i])-0x10);}else											//	Если код текущего символа равен 240...255, значит это буква «р»...«я» требующая преобразования к коду 224...239
						if( uint8_t(StrIn[i])==0xA8                            ){StrOut+=                       0xF0 ;}else											//	Если код текущего символа равен 168      , значит это буква «Ё»       требующая преобразования к коду 240
						if( uint8_t(StrIn[i])==0xB8                            ){StrOut+=                       0xF1 ;}else											//	Если код текущего символа равен 184      , значит это буква «ё»       требующая преобразования к коду 241
						                                                        {StrOut+=char(        StrIn[i]      );} i++;										//	Иначе не меняем символ.
					}																																				//
				break;																																				//
				default:    StrOut=StrIn;																															//
			}	return StrOut;																																		//	Возвращаем строку StrOut.
}																																									//